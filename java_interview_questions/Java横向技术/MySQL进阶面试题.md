# MySQL进阶面试题
### 问：简单说一说drop、delete与truncate的区别？

**参考答案：**

​	delete和truncate只删除表的数据不删除表的结构

​	速度：drop> truncate >delete

​	delete语句是dml，这个操作会放到rollback segement中，事务提交之后才生效；如果有相应的trigger，执行的时候将被触发。 truncate,drop是ddl，操作立即生效，原数据不放到rollback segment中，不能回滚。操作不触发trigger。



### 问：谈谈三大范式，什么时候使用反范式设计

**参考答案：**  

第一范式（1NF）：确保每列保持原子性即列不可分，即数据库表中的字段都是单一属性的。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。

第二范式（2NF）：属性完全依赖于主键，也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。

第三范式（3NF）：在第二范式的基础上，属性和主键不能间接相关（减少数据冗余，这样就可以通过主外键进行表之间连接）。比如我们表比较多，需要关联时，但我们的A表只需要关联B表的一个字段，而且每次都需要关联查询你，这时我们可以采用A表放置一个冗余字段来存B表的那个字段。这个操作其实就是一个反范式的。

###  

### 问：说几个mysql中你常用的函数

**参考答案：**  

sum、count 、avg、min、max



### 问：redo log和binlog的区别是什么？

**参考答案：**

1. redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。
2. redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。
3. redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。
4. redo log用于保证crash-safe能力。innodb_flush_log_at_trx_commit =1表示每次事务的redo log 都持久化到磁盘，保证mysql异常重启之后数据不丢失。Sync_binlog=1参数设置为1，表示每次事务的binlog都持久化到磁盘，保证mysql异常重启之后binlog不丢失。





### 问：说一说mysql主从复制。

**参考答案：**

在MySQL主从复制架构中，读操作可以在所有的服务器上面进行，而写操作只能在主服务器上面进行。主从复制架构虽然给读操作提供了扩展，可如果写操作也比较多的话（多台从服务器还要从主服务器上面同步数据），单主模型的复制中主服务器势必会成为性能瓶颈。

1. 基于记录的复制：主服务器上面执行的语句在从服务器上面再执行一遍，在MySQL-3.23版本以后支持。
   存在的问题：时间上可能不完全同步造成偏差，执行语句的用户也可能是不同一个用户
2. 基于语句的复制：把主服务器上面改编后的内容直接复制过去，而不关心到底改变该内容是由哪条语句引发的，在MySQL-5.0版本以后引入。
   存在的问题：比如一个工资表中有一万个用户，我们把每个用户的工资+1000，那么基于行的复制则要复制一万行的内容，由此造成的开销比较大，而基于语句的复制仅仅一条语句就可以了。

**复制过程：**

1. 在每个事务更新数据完成之前，master在二进制日志记录这些改变。写入二进制日志完成后，master通知存储引擎提交事务。 
2. Slave将master的binary log复制到其中继日志。首先slave开始一个工作线程（I/O），I/O线程在master上打开一个普通的连接，然后开始binlog dump process。binlog dump process从master的二进制日志中读取事件，如果已经跟上master，它会睡眠并等待master产生新的事件，I/O线程将这些事件写入中继日志。 
3. Sql slave thread（sql从线程）处理该过程的最后一步，sql线程从中继日志读取事件，并重放其中的事件而更新slave数据，使其与master中的数据一致，只要该线程与I/O线程保持一致，中继日志通常会位于os缓存中，所以中继日志的开销很小。



### 问：如何开启慢日志查询？

**参考答案：**

有2种方式，一是修改mysql的配置文件，二是通过set global语句来实现。slow_query_log = ON，打开日志，long_query_time = 2，设置时间，2秒就算是慢查询，然后重启mysql服务即可，进入mysql控制台，输入SET GLOBAL slow_query_log = 'ON';SET GLOBAL long_query_time = X;不需要重启服务就可以得到慢查询日志。



### 问：如何生成UUID，以及UUID的缺点？

**参考答案：**

```java
UUID uuid = UUID.randomUUID();
System.out.println(uuid);
String dxmbid = uuid.toString().replace("-", "");  System.out.println(dxmbid);
System.out.println(dxmbid.length());
```

- 缺点:

1. 占空间太大
2. 索引效率低
3. UUID是唯一随机的，不适合人读
4. 无法排序



### 问：mysql中varchar与char的区别以及varchar(50)中的50代表的含义？

**参考答案：**

（1） varchar与char的区别

​		变长和固定长度

（2）varchar(50)中50的涵义

​		字符最大长度50，所代表的字节数与字符集有关，比如是utf8占3个字节，那么varchar(50)字段在表中最大取到150个字节。

​		varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)。

（3） int（20）中20的涵义

​	是指显示字符的长度不影响内部存储，只是影响带 zerofill 定义的 int 时，前面补多少个 0，易于报表展示

（4） varchar(20)和int(20)中的20含义一样吗？

​	int(M) M表示的不是数据的最大长度，只是数据宽度，并不影响存储多少位长度的数据；varchar(M) M表示的是varchar类型数据在数据库中存储的最大长度，超过则不存；





### 问：FLOAT和DOUBLE的区别是什么？

**参考答案：**

- 浮点数以8位精度存储在FLOAT中，有四个字节。
- 浮点数以18位精度存储在DOUBLE中，有八个字节。



### 问：CHAR_LENGTH和LENGTH的区别是什么？

**参考答案：**

CHAR_LENGTH是字符数，而LENGTH是字节数。Latin字符的这两个数据是相同的，但是对于Unicode和其他编码，它们是不同的。



### 问：CHAR和VARCHAR的区别是什么？

**参考答案：**

CHAR和VARCHAR类型在存储和检索方面有所不同

- CHAR列长度固定为创建表时声明的长度，长度值范围是1到255;
- 当CHAR值被存储时，它们被用空格填充到特定长度，检索CHAR值时需删除尾随空格。



### 问：列的字符串类型可以是什么？？

**参考答案：**

SET、BLOB、ENUM、CHAR、TEXT、VARCHAR



### 问： myisamchk是用来做什么的？

**参考答案：**    

   它用来压缩MyISAM表，这减少了磁盘或内存使用。



### 问： 怎样才能找出最后一次插入时分配了哪个自动增量？

**参考答案：**    

LAST_INSERT_ID将返回由Auto_increment分配的最后一个值，并且不需要指定表名称。

###  

### 问： 你怎么看到为表格定义的所有索引？

**参考答案：**    

索引是通过以下方式为表格定义的：SHOW INDEX FROM;

###  

### 问： LIKE声明中的％和_是什么意思？

**参考答案：**    

％对应于0个或更多字符，_只是LIKE语句中的一个字符。



### 问：事务是如何通过日志来实现的，说得越深入越好

**参考答案：** 

基本流程如下：

因为事务在修改页时，要先记 undo，在记 undo之前要记 undo 的 redo， 然后修改数据页，再记数据页修改的 redo。redo（里面包括 undo 的修改） 一定要比数据页先持久化到磁盘。当事务需要回滚时，因为有 undo，可以把数据页回滚到前镜像的状态；崩溃恢复时，如果 redo log 中事务没有对应的 commit 记录，那么需要用 undo把该事务的修改回滚到事务开始之前。如果有 commit 记录，就用 redo 前滚到该事务完成时并提交掉。



### 问：BLOB和TEXT有什么区别？

**参考答案：** 

BLOB是一个二进制对象，可以容纳可变数量的数据。有四种类型：TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB，它们只是在所能容纳价值的最大长度上有所不同。

TEXT是一个不区分大小写的BLOB。有四种类型：TINYTEXT、TEXT、MEDIUMTEXT和

LONGTEXT。它们对应于四种BLOB类型，并具有相同的最大长度和存储要求。

BLOB和TEXT类型之间的唯一区别在于对BLOB值进行排序和比较时区分大小写，对TEXT值不区分大小写。



### 问：MySQL数据库cpu飙升到500%的话他怎么处理？

**参考答案：** 

当 cpu 飙升到 500%时，先用操作系统命令 top 命令观察是不是 mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。如果是 mysqld 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等

###  

### 问：SELECT * 和 SELECT 全部字段两种写法有何优缺点?

**参考答案：** 

1. 前者要解析数据字典，后者不需要；
2. 结果输出顺序，前者与建表列顺序相同，后者按指定字段顺序；
3. 表字段改名，前者不需要修改，后者需要改；
4. 后者可以建立索引进行优化，前者无法优化；
5. 后者的可读性比前者要高。

###  

### 问：**HAVNG 子句 和 WHERE 的异同点?**

**参考答案：** 

1. 语法上：where 用表中列名，having 用 select 结果别名；
2. 影响结果范围：where 从表读出数据的行数，having 返回客户端的行数
3. 索引：where 可以使用索引，having 不能使用索引，只能在临时结果集操作
4. where 后面不能使用聚集函数，having 是专门使用聚集函数的。



### 问：Explain各个字段的含义

**参考答案：** 

**(1)、explain出来的各种item的意义**

id:每个被独立执行的操作的标志，表示对象被操作的顺序。一般来说， id 值大，先被执行；如果 id 值相同，则顺序从上到下。

select_type：查询中每个 select 子句的类型。

table：名字，被操作的对象名称，通常的表名(或者别名)，但是也有其他格式。

partitions：匹配的分区信息。

type：join 类型。

possible_keys：列出可能会用到的索引。

key：实际用到的索引。

key_len：用到的索引键的平均长度，单位为字节。

ref：表示本行被操作的对象的参照对象，可能是一个常量用 const 表示，也可能是其他表的

key：指向的对象，比如说驱动表的连接列。

rows：估计每次需要扫描的行数，数值越大越不好，说明没有用好索引

filtered：rows*filtered/100 表示该步骤最后得到的行数(估计值)。

extra：重要的补充信息。

**(2)、explain 中的索引问题**

Explain 结果中，一般来说，要看到尽量用 index(type 为 const、 ref 等， key 列有值)，避免使用全表扫描(type 显式为 ALL)。比如说有 where 条件且选择性不错的列，需要建立索引。

被驱动表的连接列，也需要建立索引。被驱动表的连接列也可能会跟 where 条件列一起建立联合索引。当有排序或者 group by 的需求时，也可以考虑建立索引来达到直接排序和汇总的需求
