# JVM与垃圾回收机制
###  问：Java 虚拟机结束生命周期的几种场景？

**参考答案：**

- 执行了System.exit()方法；
- 程序正常执行结束；
- 程序在执行过程中遇到了异常或错误而异常终止；
- 由于操作系统出现错误而导致 Java 虚拟机进程终止；



### 问：为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace)？

**参考答案：**

整个永久代有一个 JVM 本身设置固定大小上线，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，并且永远不会得到 java.lang.OutOfMemoryError。你可以使用 -XX：MaxMetaspaceSize。 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。 -XX：MetaspaceSize调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。



### 问：JVM 中的 Class 只有满足什么条件被回收？

**参考答案 ：**

- 该类所有的实例都已经被 GC，也就是 JVM 中不存在该 Class 的任何实例。
- 加载该类的 ClassLoader 已经被 GC。
- 该类的 java.lang.Class 对象没有在任何地方被引用，如不能在任何地方通过反射访问该类的方法





### 问：新生代、老年代、持久代都存储哪些东西？

**参考答案：**

- 新生代：方法中new一个对象，就会先进入新生代。
- 老年代：

- - 新生代中经历了N次垃圾回收仍然存活的对象就会被放到老年代中。
  - 大对象一般直接放入老年代。
  - 当Survivor空间不足。需要老年代担保一些空间，也会将对象放入老年代。

- 永久代： 指的就是方法区。





### 问：什么时候进行**MinorGC**和FullGC

**参考答案：**

- MinorGC：当Eden区满时,触发Minor GC.
- FullGC:

- - 调用System.gc时，系统建议执行Full GC，但是不必然执行
  - 老年代空间不足
  - 方法区空间不足
  - 通过Minor GC后进入老年代的平均大小大于老年代的剩余空间
  - 堆中分配很大的对象，而老年代没有足够的空间



### 问：**MinorGC和FullGC的区别** 

**参考答案：**

- Minor GC通常发生在新生代的Eden区，在这个区的对象生存期短，往往发生GC的频率较高，回收速度比较快，一般采用复制-回收算法
- Full GC/Major GC 发生在老年代，一般情况下，触发老年代GC的时候不会触发Minor GC，所采用的是标记-清除算法

###  

### 问：Java中的引用是如何分类的？

**参考答案：**

- 强引用：GC时不会被回收
- 软引用：描述有用但不是必须的对象，在发生内存溢出异常之前被回收
- 弱引用：描述有用但不是必须的对象，在下一次GC时被回收
- 虚引用（幽灵引用/幻影引用）:无法通过虚引用获得对象，用PhantomReference实现虚引用，虚引用用来在GC时返回一个通知。



### 问：空间分配担保是什么？

**参考答案：**

在Minor GC之前，jvm会检查老年代最大可用连续空间是否大于新生代所有对象的空间。如果成立，则Minor GC是安全的。否则：

1、jvm设置不允许担保失败则立刻Full GC

\2. jvm设置允许担保失败则检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于则进行一次冒险的Minor GC 否则Full GC

PS: Full GC 其实是为了让老年代腾出更多空间



### 问：堆内存不足的原因和解决方法

**参考答案：**

这种场景最为常见，报错信息

```
java.lang.OutOfMemoryError: Java heap space
```

**原因：**

1、代码中可能存在大对象分配

2、可能存在内存泄露，导致在多次GC之后，还是无法找到一块足够大的内存容纳当前对象。

**解决方法：**

1、检查是否存在大对象的分配，最有可能的是大数组分配

2、通过jmap命令，把堆内存dump下来，使用mat工具分析一下，检查是否存在内存泄露的问题

3、如果没有找到明显的内存泄露，使用 -Xmx 加大堆内存

4、还有一点容易被忽略，检查是否有大量的自定义的 Finalizable 对象，也有可能是框架内部提供的，考虑其存在的必要性



### 问：永久代/元空间溢出的原因和解决方法

**参考答案：**

报错信息：

```
java.lang.OutOfMemoryError: PermGen space
java.lang.OutOfMemoryError: Metaspace
```



**原因：**

永久代是 HotSot 虚拟机对方法区的具体实现，存放了被虚拟机加载的类信息、常量、静态变量、JIT编译后的代码等。

JDK8后，元空间替换了永久代，元空间使用的是本地内存，还有其它细节变化：1、字符串常量由永久代转移到堆中；2、和永久代相关的JVM参数已移除；

出现永久代或元空间的溢出的原因可能有如下几种：

1、在Java7之前，频繁的错误使用String.intern方法；

2、生成了大量的代理类，导致方法区被撑爆，无法卸载；

3、应用长时间运行，没有重启。

**解决方法：**

永久代/元空间 溢出的原因比较简单，解决方法有如下几种：

1、检查是否永久代空间或者元空间设置的过小；

2、检查代码中是否存在大量的反射操作；

3、dump之后通过mat检查是否存在大量由于反射生成的代理类；

4、放大招，重启JVM。



### 问：GC overhead limit exceeded的原因和解决方法

**参考答案：**

这个异常比较的罕见，报错信息：

```
java.lang.OutOfMemoryError：GC overhead limit exceeded
```

**原因：**

这个是JDK6新加的错误类型，一般都是堆太小导致的。

Sun 官方对此的定义：超过98%的时间用来做GC并且回收了不到2%的堆内存时会抛出此异常。

**解决方法：**

1、检查项目中是否有大量的死循环或有使用大内存的代码，优化代码。

2、添加参数`-XX:-UseGCOverheadLimit`禁用这个检查，其实这个参数解决不了内存问题，只是把错误的信息延后，最终出现 java.lang.OutOfMemoryError: Java heap space。

3、dump内存，检查是否存在内存泄露，如果没有，加大内存。

##  

### 问：方法栈溢出的原因和解决方法

报错信息：



```
java.lang.OutOfMemoryError : unable to create new native Thread
```

**原因:**

出现这种异常，基本上都是创建的了大量的线程导致的，以前碰到过一次，通过jstack出来一共8000多个线程。



**解决方法:**

1、通过 *-Xss *降低的每个线程栈大小的容量

2、线程总数也受到系统空闲内存和操作系统的限制，检查是否该系统下有此限制：

/proc/sys/kernel/pid_max

/proc/sys/kernel/thread-max

max_user_process（ulimit -u）

/proc/sys/vm/max_map_count
