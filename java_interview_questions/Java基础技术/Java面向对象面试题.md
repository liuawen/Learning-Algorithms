# Java面向对象面试题

<a name="O3oTs"></a>
#### 问：抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰？为什么？
**参考答案：**<br />都不能。<br />抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的；<br />本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的；<br />synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的；<br />
<a name="NSAp3"></a>
#### 问：java.lang.Class类的newInstance方法和 java.lang.reflect.Constructor类的newInstance方法有什么区别？
**参考答案：**<br />• Class类的newInstance只能触发无参数的构造方法创建对象，而构造器类的newInstance能触发有参数或者任意参数的构造方法来创建对象。<br />• Class类的newInstance需要其构造方法是public的或者对调用方法可见的，而构造器类的newInstance可以在特定环境下调用私有构造方法来创建对象。<br />• Class类的newInstance抛出类构造函数的异常，而构造器类的newInstance包装了一个InvocationTargetException异常。<br />说明：Class类本质上调用了反射包Constructor中无参数的newInstance方法，捕获了InvocationTargetException，将构造器本身的异常抛出<br />

<a name="CADvI"></a>
#### 问：Java 中的final关键字有哪些用法？
**参考答案：**        <br />(1)修饰类：表示该类不能被继承；<br />(2)修饰方法：表示方法不能被重写；(3)修饰变量：表示变量只能一次赋值以后值不能被修改（常量）

<a name="3ttjt"></a>
#### 问：关键字swtich 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？
**参考答案：** <br />在Java 5以前，switch(expr)中，expr只能是byte、short、char、int。从Java 5开始，Java中引入了枚举类型，expr也可以是enum类型，从Java 7开始，expr还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。<br />

<a name="RQlrP"></a>
#### 问：面向对象的特征有哪些？
**参考答案：**<br />　　1.抽象：<br />　　抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。<br />　　2.继承：<br />　　继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。<br />　　3.封装：<br />　　封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。<br />　　4. 多态性：<br />　　多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。

<a name="EY2gb"></a>
#### 问：代码中如何实现多态？
**参考答案：** <br />　实现多态主要有以下三种方式:

1. 接口实现
1. 继承父类重写方法
1. 同一类中进行方法重载

<a name="fp4VJ"></a>
#### 问：overload和overide的区别？
**参考答案：**

- **Override**  可以翻译为覆盖，从字面就可以知道，它是覆盖了一个方法并且对其重写，以求达到不同的作用。对我们来说最熟悉的覆盖就是对接口方法的实现，在接口中一般只是 对方法进行了声明，而我们在实现时，就需要实现接口声明的所有方法。除了这个典型的用法以外，我们在继承中也可能会在子类覆盖父类中的方法。在覆盖要注意 以下的几点：
  1. 覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果；
  1. 覆盖的方法的返回值必须和被覆盖的方法的返回值一致；
  1. 覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类；
  1. 被覆盖的方法不能为 private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。
- **Overload**  可以翻译为重载，它是指我们可以定义一些名称相同的方法，通过定义不同的输入参数来区分这些方法，然后再调用时，VM就会根据不同的参数样式，来选择合适的方法执行。在使用重载要注意以下的几点：
  5. 在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序（当然，同一方法内的几个参数类型必须不一样，例如可以是 fun(int,float)，但是不能为 fun(int,int)）；
  5. 不能通过访问权限、返回类型、抛出的异常进行重载；
  5. 方法的异常类型和数目不会对重载造成影响；
  5. 对于继承来说，如果某一方法在父类中是访问权限是 private，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。

总之，重写（Override） 是父类与子类之间多态性的一种表现，重载 (Overload） 是一个类中多态性的一种表现。很重要的一点就是，Overloaded 的方法是可以改变返回值的类型。<br />另外：在Java语言规范中，一个方法的特征仅包括方法的名字，参数的数目和种类，而不包括方法的返回类型，参数的名字以及所抛出来的异常。在Java编译 器检查方法的重载时，会根据这些条件判断两个方法是否是重载方法。但在Java编译器检查方法的置换时，则会进一步检查两个方法（分处超类型和子类型）的 返还类型和抛出的异常是否相同。

<a name="LtfJq"></a>
#### 问：使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变?
**参考答案：**<br />使用 final 关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改
变的。例如，对于如下语句:<br />final StringBuffer a=new StringBuffer("immutable");<br />执行如下语句将报告编译期错误:<br />a=new StringBuffer("");<br />但是，执行如下语句则可以通过编译:<br />a.append(" broken!");<br /> 有人在定义方法的参数时，可能想采用如下形式来阻止方法内部修改传进来的参数对象:<br />public void method(final StringBuffer param){<br />}<br /> 实际上，这是办不到的，在该方法内部仍然可以增加如下代码来修改参数对象:<br />param.append("a");
<a name="F5pw1"></a>
#### 
<a name="dX8aa"></a>
#### 问：静态变量和实例变量的区别?
**参考答案：**

- 在语法定义上的区别：静态变量前要加 static 关键字，而实例变量前则不加。
- 在程序运行时的区别：实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。
总之，实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。

例如，对于下面的程序，无论创建多少个实例对象，永远都只分配了一个 staticVar 变量，并且每创建一个实例对象，这个 staticVar就会加1；但是，每创建一个实例对象，就会分配一个 instanceVar，即可能分配多个 instanceVar，并且每个 instanceVar 的值都只自加了 1 次。
```java
public class VariantTest{

public static int staticVar = 0;
    
public int instanceVar = 0;
    
public VariantTest(){
	staticVar++;
	instanceVar++;
	System.out.println("staticVar=" + staticVar + ",instanceVar=" + instanceVar);
}
}
```
<br />


#### 问：&和&&的区别？
**参考答案：**<br /> &运算符有两种用法：(1)按位与；(2)逻辑与。<br />&&运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&&之所以称为短路运算是因为，如果&&左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&&而不是&，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &&!username.equals("")，二者的顺序不能交换，更不能用&运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。

<a name="LHL1x"></a>
#### 问：父类的静态方法能否被子类重写？
**参考答案：**<br />不能。重写只适用于实例方法，不能用于静态方法，而子类当中含有和父类相同签名的静态方法，我们一般称之为隐藏，调用的方法为定义的类所有的静态方法。

<a name="8pmGK"></a>
#### 问：什么是不可变对象？
**参考答案：**<br />不可变对象指对象一旦被创建，状态就不能再改变。任何修改都会创建一个新的对象，如 String、Integer及其它包装类。

<a name="7xxS5"></a>
#### 问：能否创建一个包含可变对象的不可变对象?
**参考答案：**<br />可以，不过需要谨慎一点，不要共享可变对象的引用就可以了，如果需要变化时，就返回原对象的一个拷贝。<br />最常见的例子就是对象中包含一个String对象的引用.




