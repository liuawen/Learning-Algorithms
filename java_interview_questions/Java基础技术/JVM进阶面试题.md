# JVM进阶面试题
###   问：常用的调优命令有哪些

**参考答案：**

- jps，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程；
- jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据；
- jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数；
- jmap，JVM Memory Map命令用于生成heap dump文件；
- jstack，用于生成java虚拟机当前时刻的线程快照；
- jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看。

![扩展阅读_命令行.png](https://i.loli.net/2020/03/03/ueGSaKJR4VoAt5Y.png)



### 问：常用的调优工具有哪些？

**参考答案：**

常用调优工具分为两类：**jdk自带监控工具：**jconsole、jvisualvm；**第三方**：MAT(Memory Analyzer Tool)、GChisto等。

- jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控
- jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。
- MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗
- GChisto，一款专业分析gc日志的工具



### 问：什么是即时编译器?

**参考答案：**

Java程序最初是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频 繁，就会把这些代码认定为“热点代码”(Hot Spot Code)。

为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机 器码，并进行各种层次的优化，完成这个任务的编译器成为即时编译器(Just In Time Compiler，JIT编译器)。





### 问：热点代码有哪些?

**参考答案：**

- 被多次调用的方法；
- 被多次执行的循环体；



### 问：如何判断一段代码是不是热点代码?

**参考答案：**



- **基于采样的热点探测**，虚拟机周期性检查各个线程的栈顶，如果发现某个方法经常出现在栈顶，那这个方法就是“热点方法”。实现简单高效，但是很难精确确认一个方法的热度。
- **基于计数器的热点探测**，虚拟机会为每个方法建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值，就认为它是热点方法。

HotSpot虚拟机使用第二种，有两个计数器：**方法调用计数器**和**回边计数器(判断循环代码)**

方法调用计数器统计方法：统计的是一个相对的执行频率，即一段时间内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器的**热度衰减**，这个时间就被称为**半衰周期**。





### 问：什么是解释器和编译器？

**参考答案：**

​     许多主流的商用虚拟机，都同时包含解释器和编译器。

当程序需要快速启动和执行时，**解释器**首先发挥作用，省去编译的时间，立即执行。 当程序运行后，随着时间的推移，**编译器**逐渐发挥作用，把越来越多的代码编译成本地代码，可以提高执行效率。 如果内存资源限制较大(部分嵌入式系统)，可以使用解释执行节约内存，反之可以使用编译执行来提升效率。同时编译器的代码还能退回成解释器的代码。



### 问：Java的方法调用，有什么特殊之处?

**参考答案：**

Class文件的编译过程**不包含**传统编译的**连接步骤**，一切方法调用在Class文件里面存储的都只是**符号引用**，而不是方法在实际运行时内存布局中的入口地址。这使得Java有强大的动态扩展能力，但使Java方法的调用过程变得相对复杂，需要在类加载期间甚至到运行时才能确定目标方法的直接引用。



### 问：Java虚拟机调用字节码指令有哪些?

**参考答案：**

invokestatic:调用静态方法

invokespecial:调用实例构造器方法、私有方法和父类方法

invokevirtual:调用所有的虚方法

invokeinterface:调用接口方法



### 问：虚拟机是如何执行方法里面的字节码指令的?

**参考答案：**

- **解释执行**(通过解释器执行)
- **编译执行**(通过即时编译器产生本地代码)解释执行

当主流的虚拟机中都包含了即时编译器后，Class文件中的代码到底会被解释执行还是编译执行，只有虚拟机自己才能准确判断。

Javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。因为这一动作是在Java虚拟机之外进行的，而解释器在虚拟机的内部，所以Java程序的编译是半独立的实现。


# JVM进阶面试题
### 问：Java 是如何实现跨平台的？

**参考答案：**



​     Java 源码编译后会生成一种.class 文件，称为字节码文件。Java 虚拟机（JVM）就是负责将字节码文件翻译成特定平台下的机器码然后运行，也就是说，只要在不同平台上安装对应的JVM，就可以运行字节码文件，运行我们编写的Java 程序。

而这个过程，我们编写的Java 程序没有做任何改变，仅仅是通过JVM 这一 “中间层” ，就能在不同平台上运行，真正实现了 “一次编译，到处运行” 的目的。

![扩展阅读_JVM示意图.png](https://i.loli.net/2020/03/03/Fi4shvgrpSzbJHa.png)

**注意：跨平台的是Java 程序，而不是JVM。JVM是用C/C++ 开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的JVM**



### 问：什么是内存屏障？

**参考答案：**    内存屏障，又称内存栅栏，是一组处理器指令，用于实现对内存操作的顺序限制。



### 问：内存屏障为何重要？

 **参考答案：**

对主存的一次访问一般花费硬件的数百次时钟周期。处理器通过缓存（caching）能够从数量级上降低内存延迟的成本这些缓存为了性能重新排列待定内存操 作的顺序。也就是说，程序的读写操作不一定会按照它要求处理器的顺序执行。当数据是不可变的，同时/或者数据限制在线程范围内，这些优化是无害的。如果把 这些优化与对称多处理（symmetric multi-processing）和共享可变状态（shared mutable state）结合，那么就是一场噩梦。当基于共享可变状态的内存操作被重新排序时，程序可能行为不定。一个线程写入的数据可能被其他线程可见，原因是数据 写入的顺序不一致。适当的放置内存屏障通过强制处理器顺序执行待定的内存操作来避免这个问题。



### 问：对象的内存布局是怎样的？

**参考答案：** 

对象的内存布局包括三个部分：对象头，实例数据和对齐填充。

**（1）、对象头：**

第一部分是与对象在运行时状态相关的信息，长度通过与操作系统的位数保持一致。包括对象的哈希值、GC分代年龄、锁状态以及偏向线程的ID等。由于对象头信息是与对象所定义的信息无关的数据，所以使用了非固定的数据结构，以便存储更多的信息，实现空间复用。因此对象在不同的状态下对象头的存储信息有所差别。

![扩展阅读_对象头分布.jpeg](https://i.loli.net/2020/03/03/wQjlST17ghNR6Jz.jpg)

另一部分是类型指针，即指向该对象所属类元数据的指针，虚拟机通常通过这个指针来确定该对象所属的类型（但并不是唯一方式）。

另外，如果对象是一个数组，在对象头中还应该有一块记录数组长度的数据，因为JVM可以通过对象的元数据确定对象的大小，但不能通过元数据确定数组的长度。

**（2）、实例数据：**

​         实例数据存储的是真正的有效数据，即各个字段的值。无论是子类中定义的，还是从父类继承下来的都需要记录。这部分数据的存储顺序受到虚拟机的分配策略以及字段在类中的定义顺序的影响。

**（3）、对齐补充：**

这部分数据不是必然存在的，因为对象的大小总是8字节的整数倍，该数据仅用于补齐实例数据部分不足整数倍的部分，充当占位符的作用。



### 问：能保证GC 执行吗？

**参考答案：** 

不能，虽然你可以调用System.gc() 或者Runtime.gc()，但是没有办法保证GC 的执行。
