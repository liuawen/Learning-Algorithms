思路
标签：哈希映射
这道题本身如果通过暴力遍历的话也是很容易解决的，时间复杂度在 O(n2)O(n2)
由于哈希查找的时间复杂度为 O(1)O(1)，所以可以利用哈希容器 map 降低时间复杂度
遍历数组 nums，i 为当前下标，每个值都判断map中是否存在 target-nums[i] 的 key 值
如果存在则找到了两个值，如果不存在则将当前的 (nums[i],i) 存入 map 中，继续遍历直到找到为止
如果最终都没有结果则抛出异常

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for(int i = 0; i< nums.length; i++) {
            if(map.containsKey(target - nums[i])) {
                return new int[] {map.get(target-nums[i]),i};
            }
            map.put(nums[i], i);
        }
        throw new IllegalArgumentException("No two sum solution");
    }
}

```

不要忘记了哈希碰撞的存在，如果存在链表的话，哈希查找的时间复杂度不一定为 O(1)，这仅仅是理想的状态下的时间复杂度，你要对最小时间和最大时间进行一个平均计算，获得平均时间复杂度。

而且 jdk1.8之后的hashmap引入了红黑树，链表数量超过8位，则用红黑树去存储数据。时间复杂度又不一样

因为都是数字，数字的哈希值就是本身，所以根本不存在碰撞，官方很牛逼的。你有点秀了。

这是给入门考试用的。其实时间复杂度和使用体验的关系也很难说，毕竟还跟硬件架构有关。

 key是数字~
 题解很棒，最好能说明一下为什么不怕重复。看评论里有很多人提出这个问题，说hash冲突。 我在这里解答一下这个问题。 1.每次写入时，判断条件 不是当前的key本身存不存在，而是key和 tag 之间的差值存不存在，这一点很重要。 2.题目命题说明了一点，假定只有一个解。也就是说重复元素再多都无所谓。 case 1：如果有3个或者以上的重复元素，代表这个重复元素不可能是解，所以写入map的时候直接覆盖也无所谓； case2：如果只有两个重复元素，同样的道理，假如这个重复元素是解，那么必定是两个重复元素的和等于tag。这种情况下，当遇到第二个重复元素时，不会写入map，这个时候直接已经取到解了。 所以这种方式，不用考虑hash冲突的问题。
 
 哈希冲突和重复key有区别吧，哈希冲突主要是是由于哈希函数产生的哈希值是有限的
 
 shmap自己会解决冲突的问题
 
  赞同，这是两个概念，hash冲突，java中的hashmap会自己解决hash冲突的问题，但是出现hash冲突时，hashmap的效率就会从O(1)向O(N)降低，你可以测一下自己写个hash函数，让每个值得hash值变成相同的，然后向hashmap中插入63个，你看看还是不是O（1）
  
  并不会的哦 如果数组有重复的数据 那么map中键对应的值肯定是数组中两个重复值中的后者，但是循环数组时 先取到的是数组中重复值的前者，所以说重复数是没有关系的哦
  
  这是把值作为KEY,序号作为VALUE？如果值相同怎么办呢？会报错吧
  
  值相同的话后添加的就把前面的覆盖啦。但这种情况并不会影响最终结果
  
  一开始老是不能理解为什么value添加的是 i,看了你的图解才焕然大悟,果然还是思维不够活跃,得多锻炼才行
  
  key 相同时怎么定位value
  
  HashMap集合key不可能相同,除非你用的是自定义类对象,添加不同的对象相同的内容,没有重写方法
  
  终于明白所谓的哈希是咋回事了，跟那种直接查就是方向不同。哈希向前查找次数是 0，1，2，3。 那种是向后查次数是3，2，1，0。怎么看都差不多没啥优越性。 而且哈希还费了一点事就是，存了个键值对，别说存储不耗费CPU资源？楼主还是不错的把那么一堆没用的代码给直观的展现出来了，我也想学画画了。
 